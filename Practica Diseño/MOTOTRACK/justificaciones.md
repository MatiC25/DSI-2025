### Dificultad
- Decidi modelar a la dificultad como un enum ya que no tiene comportamientos propios  y es un conjunto cerrado de valores. Esto garantiza la Integridad Referencial y evita errores de tipeo (favoreciendo la Robustez).

### TipoTerreno 
- Modelé a la entidad tipoTerreno como una entidad/clase en lugar de un string o enum para encapsular la lógica y atributos relacionados al tipo de terreno dentro de su propia clase, favoreciendo la Cohesión (respondiendo al principio solid de Responsabilidad Única). Además, esto permite la Extensibilidad futura (agregar nuevos atributos o comportamientos al tipo de terreno sin afectar otras partes del sistema o agregar nuevos tipos de terrenos sin tener que modificar el código). Por otro lado el enunciado me da la pista de que en un futuro podrían agregarse nuevos tipos de terrenos con diferentes atributos o comportamientos, por lo que modelarlo como una clase me permite adaptarme mejor a esos posibles cambios futuros (respondiendo al principio solid de Abierto/Cerrado).

### Categoria del Motoquero
- Decidi modelar a la categoría del motoquero como una clase ya que, si bien podría tener comportamientos propios al realizar la validación de si puede o no pasar al siguiente nivel (pensando en un Patrón State el cuál tiene transiciones) pienso que en este caso no es necesario ya que la lógica de validación se puede manejar cada vez que se recorra un camino. Esta solución favorece a la simplicidad del sistema. En cambio si lo hacemos como una interfaz o clase, estaríamos agregando complejidad innecesaria al sistema (violando el principio de KISS) 

- Decidir modelar a la categoría del motoquero como una entidad/clase en vez de aplicar el patrón State, ya que en este caso no amerita ser modelada con esta implemenación ya que no existen comportamientos especificos por cada una de las categorias. Además no existen transiciones muy marcadas como para que sea justificado el uso de este patrón. Por otro lado, al modelarla como una clase, se favorece la simplicidad del sistema (respondiendo al principio KISS - Keep It Simple, Stupid), evitando la complejidad innecesaria que podría surgir al implementar el patrón State sin una necesidad clara, teniendola como una clase logra su cometido sin agregar complejidad extra al sistema.